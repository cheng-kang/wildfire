path /users {
    read() { true }
    index() { ['email'] }

    /{uid} {
        // `.isAdmin` is not writable by any users including admin user.
        create() { this.isAdmin == null }
        update() { this.isAdmin == null && prior(this).isAdmin == null && isCurrentUser(uid) || isAdmin() }
        delete() { false }
    }
}

path /comments {
    read() { true }
    index() { ['rootCommentId', 'pageURL'] }

    /{commentId} {
        // TODO: Comment should only be created under condition:
        //          this.authorUid == 'anonymous' || this.authorUid == auth.uid
        create() { true }
        update() { false }
        delete() { canDeleteComment(this) || isAdmin() }
    }
}

path /pageComments {
    read() { true }
    write() { true }
}

path /votes {
    read() { true }
    write() { true }
    // /{commentId} {
    //     write() {prior(root).}
    // }
    // /{commentId}/{type}/{uid} {
    //     write() { isCurrentUser(uid) || isAdmin() }
    // }

    // Notes:
    //  Ideally, except for admin users,
    //      (1) votes data should only be created by the voting user,
    //      (2) votes data should not be updated by any user,
    //      (3) votes data should only be removed by 
    //          i. it's voter, or 
    //          ii. comment author, or 
    //          iii. root comment author
    //  I'm not declaring these rules at the moment because the votes data
    //  is not that important to have such complex rules. 
    //  Might reconsider this issue in the future though.
}

path /notifications/{uid} {
    read() { isCurrentUser(uid) }

    /{notifId} {
        create() { true }
        update() { isCurrentUser(uid) || isAdmin() }
        delete() { isCurrentUser(uid) || isAdmin() }
    }
}

path /reported {
    read() { isAdmin() }

    /{commentId}/{uid} {
        read() { isCurrentUser(uid) || isAdmin() }
        create() { isCurrentUser(uid) }
        update() { isAdmin() }
        delete() { isAdmin() }
    }
}

path /ban {
    read() { true }
    write() { isAdmin() }
}

// r: read access, c: create access, u: update access, d: delete access
// t: node type [s(single), c(collection)]
path /plugins/{pluginName}/{r}/{c}/{u}/{d} {
  /u/{key} {
    read() { hasAccessUnowned(this, r) }
    create() { hasAccessUnowned(this, c) }
    update() { hasAccessUnowned(this, u) }
    delete() { hasAccessUnowned(this, d) }
  }
  
  /o1/{key} {
    read() { hasAccessOwned(this, r, key) }
    create() { hasAccessOwned(this, c, key) }
    update() { hasAccessOwned(this, u, key) }
    delete() { hasAccessOwned(this, d, key) }
  }
  /o2/{nodeName}/{key} {
    read() { hasAccessOwned(this, r, key) }
    create() { hasAccessOwned(this, c, key) }
    update() { hasAccessOwned(this, u, key) }
    delete() { hasAccessOwned(this, d, key) }
  }
}

function hasAccessUnowned (this, code) {
    code.includes('a') ?
        true :              
    (code.includes('s') ?
        isSignedInUser() :
    // code.includes('x') ?
        isAdmin()
    )
}
function hasAccessOwned (this, code, key) {
    code.includes('a') ?
        true :  
    (code.includes('s') ?
        isSignedInUser() :  
    (code.includes('r') ?
        isRelatedUser(this, key) :
    (code.includes('o') ?
        isOwner(this, key) :
    // code.includes('x') ?
        isAdmin()
    )))
}

function isCreate (this) { prior(this) == null }

function isSignedInUser () { auth != null }
function isRelatedUser (this, key) { 
    prior(this).relatedUser == auth.uid || isOwner(this, key)
}
function isOwner (this, key) { 
  key == auth.uid ||
  (isCreate(this) ? 
    this.ownerUid == auth.uid :
  // isUpdate, isDelete ? 
    prior(this).ownerUid == auth.uid)
}
function isAdmin () { 
  prior(root).users[auth.uid].isAdmin == true 
}

function isCurrentUser (uid) { auth != null && auth.uid == uid }

function canDeleteComment (this) { isCommentAuthor(this) || isRootCommentAuthor(this) }
function isCommentAuthor (this) { prior(this).uid == auth.uid }
function isRootCommentAuthor (this) { prior(this).rootCommentUid == auth.uid }